use convert_case::{Case, Casing};
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;
use std::process::Command;

fn main() {
    // Rerun if Solidity sources or compiled artifacts change
    println!("cargo:rerun-if-changed=contracts/src/");
    println!("cargo:rerun-if-changed=contracts/out/");
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/contract_bindings.rs");

    // Run forge build to compile Solidity contracts
    let contracts_dir = Path::new("contracts");
    if contracts_dir.exists() {
        let status = Command::new("forge")
            .args(["build"])
            .current_dir(contracts_dir)
            .status()
            .expect("Failed to execute forge build. Is forge installed and in PATH?");

        if !status.success() {
            panic!("forge build failed with exit code: {:?}", status.code());
        }
    }

    let contracts_out_dir = Path::new("contracts/out");
    let bindings_file = Path::new("src/contract_bindings.rs");

    // Collect all contract JSON files
    let mut contracts: Vec<(String, String)> = Vec::new();

    if contracts_out_dir.exists() {
        for entry in fs::read_dir(contracts_out_dir).expect("Failed to read contracts/out directory")
        {
            let entry = entry.expect("Failed to read directory entry");
            let path = entry.path();

            // Each contract is in a directory named ContractName.sol
            if path.is_dir() {
                let dir_name = path.file_name().unwrap().to_str().unwrap();

                // Skip non-contract directories
                if !dir_name.ends_with(".sol") {
                    continue;
                }

                // Extract contract name from directory name (e.g., "GateLock.sol" -> "GateLock")
                let contract_name = dir_name.trim_end_matches(".sol");

                // Find the JSON file inside (e.g., "GateLock.json")
                let json_file = path.join(format!("{}.json", contract_name));

                if json_file.exists() {
                    let json_path = json_file.to_str().unwrap().to_string();
                    contracts.push((contract_name.to_string(), json_path));
                }
            }
        }
    }

    // Generate the bindings file
    let mut output = String::new();
    output.push_str("//! Auto-generated contract bindings. Do not edit.\n");
    output.push_str("//! This file is generated by build.rs\n\n");

    for (contract_name, json_path) in &contracts {
        // Convert PascalCase to snake_case for module name
        let module_name = contract_name.to_case(Case::Snake);

        output.push_str(&format!(
            r#"#[rustfmt::skip]
pub mod {module_name} {{
    alloy::sol!(
        #[allow(missing_docs)]
        #[sol(rpc, abi)]
        #[derive(Debug, Default, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
        {contract_name},
        "{json_path}"
    );
}}

"#
        ));
    }

    // Write the bindings file
    let mut file = File::create(bindings_file).expect("Failed to create contract_bindings.rs");
    file.write_all(output.as_bytes())
        .expect("Failed to write contract_bindings.rs");
}
